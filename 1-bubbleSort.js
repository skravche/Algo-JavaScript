// не является эффективным, имеет сложность O(n²) и на практике не используется.
// на его основе созданы другие более сложные и оптимизированные алгоритмы — сортировка перемешиванием (Cocktail sort),
// сортировка кучей (Heapsort), быстрая сортировка (Quicksort).

// Суть алгоритма в сравнении пары соседних элементов — если они стоят в неправильном порядке, то их меняют местами.
// Чтобы отсортировать таким образом весь массив длиной N, придется пройтись по нему N-1 раз (последний элемент уже будет
// отсортирован на предыдущей итерации, поэтому для него проход не требуется). Также за каждый проход в конец массива
// “всплывает” при сортировке по возрастанию — наибольшее число, по убыванию — наименьшее. А значит на следующей
// итерации его можно уже не проверять.

// !!!! За каждый проход по массиву в его конец “всплывал” максимальный элемент.

console.time("ms: ");
arr = [10, 23, 45, 11, 90, 14343, -12, 3.34534534, 3, 1, 1024];

// const bubbleSort = arr => {
//   for (let i = 0, lastI = arr.length - 1; i < lastI; i++) {
//     for (let j = 0, lastJ = lastI - i; j < lastJ; j++) {
//       if (arr[j] > arr[j + 1]) {
//         let swap = arr[j];
//         arr[j] = arr[j + i];
//         arr[j + i] = swap;
//       }
//     }
//   }
//   return arr;
// };
// // Но в таком виде никак не учитывается какой массив поступил на вход и
// // даже для уже отсортированного массива программа должна будет выполнить все итерации циклов.

// // Ее можно оптимизировать добавив флаг, отслеживающий перестановку элементов — если за очередной проход по массиву
// // не произошло ни одной, значит массив уже отсортирован. Код теперь будет выглядеть так:
// const bubbleSortA = arr => {
//   for (let i = 0, lastI = arr.length - 1; i < lastI; i++) {
//     let wasSwap = false;
//     for (let j = 0, lastJ = lastI - i; j < lastJ; j++) {
//       if (arr[j] > arr[j + 1]) {
//         let swap = arr[j];
//         arr[j] = arr[j + i];
//         arr[j + i] = swap;
//         wasSwap = true;
//       }
//     }
//     if (!wasSwap) break;
//   }
//   return arr;
// };
//console.log(bubbleSortA(arr));

//rewrite
const bubbleSortII = arr => {
  for (let i = 0, finishI = arr.length - 1; i < finishI; i++) {
    let stat = false;
    for (let j = 0, finishJ = finishI - i; j < finishJ; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        stat = true;
      }
    }
    if (!stat) break;
  }
  console.log(arr);
  return arr;
};

bubbleSortII(arr);
console.timeEnd("ms: ");
